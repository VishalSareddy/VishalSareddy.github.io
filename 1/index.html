<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Project 1</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f0f8ff; /* light blue background */
      color: #003366; /* dark blue text */
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    h1 {
      font-size: 2.5rem;
      margin-bottom: 30px;
      color: #004c99;
      text-shadow: 1px 1px 2px #cce6ff;
    }

    h2 {
      font-size: 1.8rem;
      margin: 20px 0 15px;
      color: #004c99;
    }

    p {
      font-size: 1rem;
      line-height: 1.6;
      margin-bottom: 15px;
      color: #003366;
    }

    .section {
      background: white;
      border-radius: 15px;
      padding: 20px;
      margin-bottom: 40px;
      box-shadow: 0px 4px 10px rgba(0,0,0,0.1);
      width: 85%;
      max-width: 1100px;
    }

    /* Part 1 image row */
    .image-row {
      display: flex;
      justify-content: center;
      gap: 20px;
      flex-wrap: wrap;
      margin-top: 15px;
    }

    .image-row figure {
      width: 40%;
      text-align: center;
    }

    .image-row img {
      width: 100%;
      border-radius: 12px;
      box-shadow: 0px 3px 8px rgba(0,0,0,0.1);
    }

    .image-row figcaption {
      font-size: 0.95rem;
      margin-top: 10px;
      color: #004c99;
      text-align: center;
    }

    /* Part 2 image grid */
    .image-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 25px;
      margin-top: 15px;
    }

    .image-grid figure {
      text-align: center;
    }

    .image-grid img {
      width: 100%;
      height: auto;
      border-radius: 12px;
      box-shadow: 0px 3px 8px rgba(0,0,0,0.1);
    }

    .image-grid figcaption {
      font-size: 0.9rem;
      margin-top: 10px;
      color: #004c99;
      text-align: center;
    }
    
    a.back-button {
      text-decoration: none;
      background-color: #66b2ff;
      color: white;
      padding: 10px 20px;
      border-radius: 10px;
      font-size: 1rem;
      font-weight: bold;
      transition: background-color 0.3s, transform 0.2s;
      box-shadow: 0px 4px 8px rgba(0,0,0,0.1);
      margin: 20px 0;
      display: inline-block;
    }

    a.back-button:hover {
      background-color: #3399ff;
      transform: translateY(-2px);
    }
  </style>
</head>
<body>
  <h1>Project 1</h1>

  <!-- Overview Section -->
  <div class="section">
    <h2>Project 1 Overview</h2>
    <p>
      <!-- Replace with your paragraph -->
      This project is intended to take the digitized Prokudin-Gorskii glass plate images and use image processing techniques to produce color images. 
      This is done via image alignment, taking three color channel images and stacking them into a single RGB color image. We do this through a single-scale 
      image alignment function and by building a multi-scale image pyramid. The approach and images for each are shown below.
    </p>
  </div>

  <!-- Part 1 Section -->
  <div class="section">
    <h2>Part 1: Single-Scale Image Alignment</h2>
    <p>
      <!-- Replace with your paragraph -->
      The purpose of this section is to implement an exhaustive window search algorithm using a range of displacements in order to align the 3-channel images. 
      For my displacement range, I chose [-15, 15] as that was the window provided as an example in the spec and it seemed to work for the relevant 
      images. </br> </br>
      I tried both L2 norm (Euclidean distance) and Normalized Cross-Correlation (NCC) as metrics to score/measure how well any two channels are aligned for a 
      given image. For L2, I aimed to minimize the value (intuitive to the distance-based nature of the metric), whereas for NCC, I aimed to maximize the value 
      (correlation closer to 1 indicates greater pixel matching). After trying both metrics, NCC seemed to work better so I kept that metric for scoring how well 
      my images aligned and determining the proper x-axis and y-axis displacements to best align each channel of each image. </br> </br>
      It is worth noting, though, that my initial single-scale alignment function, looping over each displacement window combination (using np.roll) and 
      scoring the alignment using NCC, was not quite accurate. This was a result of the messy edges around each channel, which messed up the reliability of the 
      NCC scoring metric by adding unnecessary weight to parts of the image that are not relevant. To mitigate this, I implemented a border cropping mechanism 
      within my alignment function, which did a 30% border crop on all sides of the shifted test image channel and base image channel before computing the NCC 
      metric for each shifted image. This enabled my function to output better displacement offsets, allowing for a much cleaner image alignment and a more 
      reliable single-scale image alignment function. Please enjoy the images below!
    </p>
    <div class="image-row">
      <figure>
        <img src="cathedralA.jpg" alt="Part 1 Image 1">
        <figcaption>Cathedral; Blue-Green Offsets [5, 2]; Blue-Red Offsets [12, 3]</figcaption>
      </figure>
      <figure>
        <img src="monasteryA.jpg" alt="Part 1 Image 2">
        <figcaption>Monastery; Blue-Green Offsets [-3, 2]; Blue-Red Offsets [3, 2]</figcaption>
      </figure>
      <figure>
        <img src="tobolskA.jpg" alt="Part 1 Image 3">
        <figcaption>Tobolsk; Blue-Green Offsets [3, 3]; Blue-Red Offsets [7, 3]</figcaption>
      </figure>
    </div>
  </div>

  <!-- Part 2 Section -->
  <div class="section">
    <h2>Part 2: Multi-Scale Image Pyramid</h2>
    <p>
      <!-- Replace with your paragraph -->
      	The purpose of this section was to implement a multi-scale image pyramid alignment algorithm for aligning the bigger .TIF files. This was needed 
        because the .TIF files were of a much higher resolution, which would require larger displacement windows, making single-scale exhaustive search to 
        be far more expensive and time consuming (testing single-scale on a sample .TIF file was running for over 3-4 minutes before I had to quit running 
        the algorithm). For this reason, I implemented an image pyramid, which represents the image at multiple scales (or levels) and then sequentially 
        processes the image from the coarsest image (smallest scale) up until the finest image (largest scale or the whole image). Throughout this process, 
        the estimated optimal displacement value for image alignment is gradually adjusted at each level, enabling a much faster search and quicker alignment 
        for larger resolution images. </br></br>
        I used my single-scale alignment function in order to implement this image pyramid, considering that it serves as a useful base case (level=0) for a 
        recursive function that represents the image pyramid algorithm. For this, I kept many of the same hyperparameters, including the 30% border cropping 
        and the same NCC scoring mechanic (displacement window is the exception here). When recursing from a higher to lower level, my image pyramid generated 
        a proper downsampled image by using the cv.resize tool, which implemented lowpass Gaussian pre-filtering and then subsampling (rescaling the image by 0.5 
        or Â½ for each level decrease). This downsampled image was then passed into the recursive call to the lower level, epitomizing the processing of a coarser 
        image. After the displacements of a lower level are calculated, they are then transferred to the upper level (finer image) and rescaled (multiplied by 2) 
        and fine tuned by shifting the upper level image and passing it into the single-scale alignment function with a small displacement window for refinement 
        (in my case, I used [-2, 2]). This generated the updated displacements all the way up to the finest image, which then provided the necessary optimal 
        displacements to align the images. </br></br>
        Perhaps the biggest thing worth noting was that the necessary displacement window was a lot higher, changing from [-15, 15] with the .JPG files in 
        single-scale alignment up to [-50, 50] for the higher resolution .TIF files. This made it such that the optimal level parameter for the .JPG files was 
        much smaller (I used level=1) than for the .TIF files (level=1 makes the algorithm too slow and level=3 was much better and what I used). Furthermore, 
        the emir.tif alignment was incredibly off with my algorithm, a fact that I believe is due to the distorted brightness values for each channel. This 
        makes NCC a quite bad scoring mechanism for the emir.tif file. Otherwise, please enjoy the images below!
    </p>
    <div class="image-grid">
      <figure>
        <img src="cathedralB.jpg" alt="Part 2 Image 1">
        <figcaption>Cathedral; Blue-Green Offsets [5, 2]; Blue-Red Offsets [12, 3]</figcaption>
      </figure>
      <figure>
        <img src="monasteryB.jpg" alt="Part 2 Image 2">
        <figcaption>Monastery; Blue-Green Offsets [-3, 2]; Blue-Red Offsets [3, 2]</figcaption>
      </figure>
      <figure>
        <img src="tobolskB.jpg" alt="Part 2 Image 3">
        <figcaption>Tobolsk; Blue-Green Offsets [3, 3]; Blue-Red Offsets [7, 3]</figcaption>
      </figure>
      <figure>
        <img src="church.jpg" alt="Part 2 Image 4">
        <figcaption>Church; Blue-Green Offsets [25, 4]; Blue-Red Offsets [58, -4]</figcaption>
      </figure>
      <figure>
        <img src="emir.jpg" alt="Part 2 Image 5">
        <figcaption>Emir; Blue-Green Offsets [48, 24]; Blue-Red Offsets [-214, 4]</figcaption>
      </figure>
      <figure>
        <img src="harvesters.jpg" alt="Part 2 Image 6">
        <figcaption>Harvesters; Blue-Green Offsets [59, 17]; Blue-Red Offsets [123, 15]</figcaption>
      </figure>
      <figure>
        <img src="icon.jpg" alt="Part 2 Image 7">
        <figcaption>Icon; Blue-Green Offsets [41, 17]; Blue-Red Offsets [90, 23]</figcaption>
      </figure>
      <figure>
        <img src="italil.jpg" alt="Part 2 Image 8">
        <figcaption>Italil; Blue-Green Offsets [38, 21]; Blue-Red Offsets [76, 36]</figcaption>
      </figure>
      <figure>
        <img src="lastochikino.jpg" alt="Part 2 Image 9">
        <figcaption>Lastochikino; Blue-Green Offsets [-3, -2]; Blue-Red Offsets [75, -8]</figcaption>
      </figure>
      <figure>
        <img src="lugano.jpg" alt="Part 2 Image 10">
        <figcaption>Lugano; Blue-Green Offsets [40, -16]; Blue-Red Offsets [92, -28]</figcaption>
      </figure>
      <figure>
        <img src="melons.jpg" alt="Part 2 Image 11">
        <figcaption>Melons; Blue-Green Offsets [82, 10]; Blue-Red Offsets [178, 13]</figcaption>
      </figure>
      <figure>
        <img src="self_portrait.jpg" alt="Part 2 Image 12">
        <figcaption>Self_Portrait; Blue-Green Offsets [78, 29]; Blue-Red Offsets [175, 37]</figcaption>
      </figure>
      <figure>
        <img src="siren.jpg" alt="Part 2 Image 13">
        <figcaption>Siren; Blue-Green Offsets [49, -5]; Blue-Red Offsets [96, -24]</figcaption>
      </figure>
      <figure>
        <img src="three_generations.jpg" alt="Part 2 Image 14">
        <figcaption>Three_Generations; Blue-Green Offsets [50, 15]; Blue-Red Offsets [110, 13]</figcaption>
      </figure>
    </div>
  </div>

  <!-- Back Button -->
  <a href="../index.html" class="back-button">Back to Home</a>
</body>
</html>
